#pragma once
#include "stdafx.h"
#include "MatrixOps.h"

using std::array;
/**
This class represents an input layer in the neural network and contains all the methods to perform operations on it
*/
class InputLayer
{
protected:

	short index = 0; /**< Index of next train in the array */

public:

	array<array<double, TYI>, CLASSES*NEURONS_IN> w; /**< The weights w for every synapse*/
	array<array<bool, T>, NEURONS_IN> trains; /**< The trains of spikes generated by rate encoding process */
	array<array<double, Ka>, TYI> basis; /**< The basis matrix A contains the basis functions to apply to the weights w */

	/**
	The cosntructor initialises the values of the weights and the basis matrix
	*/
	InputLayer();
	/**
	Adds a train of spikes to the array, as position [index]
	@param train The train of spikes
	*/
	void AddTrain(array<bool, T>& train);
	/**
	Reset the values of the trains and index
	*/
	void ResetTrains();
	/**
	Convolve alphas with the trains and apply the basis matrix.
	This is one part of the process to compute the potential of the output neuron
	@return The preprocessed spike trains
	*/
	array<array<double, T-1>, CLASSES*NEURONS_IN> ApplyAlphas();
	/**
	Updates the weights w using the errors
	@params errors The errors for updating the weights
	*/
	void UpdateAlphas(array<array<double, TYI>, CLASSES*NEURONS_IN>& gradients);
};

/**
This class represents an output layer in the neural network and contains all the methods to perform operations on it
*/
class OutputLayer
{
protected:

	array<array<double, T>, CLASSES> u; /**< The potential of every output neuron at every time t */
	array<array<bool, T>, CLASSES> y; /**< The output spike trains of every class */
	array<double, T> q;
	array<double, T> h;

public:

	array<double, CLASSES> gammas; /**< The biases of every class*/

	/**
	The cosntructor initialises the values of the weights and the basis matrix
	*/
	OutputLayer();
	/**
	Reset the values of the potential and output
	*/
	void Reset();
	/**
	Computes the potential and output starting from the preprocessed trains
	@param synapsesOut The preprocessed spike trains from the input layer
	*/
	void ComputeOutput(array<array<double, T-1>, CLASSES*NEURONS_IN>& synapsesOut);

	/**
	Returns the "Winner" of the network: uses rate decoding to determine the class with the most spikes
	@return The prediction of the network
	*/
	char ComputeWinner() const;

	array<double, T> FTSProbability(char label);

	/**
	Computes the normalization factor q
	@param label The correct digit
	 */
	void ComputeQ(char label);

	/**
	Computes the weight h
	@param label The correct digit
	 */
	void ComputeH(char label);

	/**
	Compute the gradient of the input weights
	@param label The correct digit
	@param basisInput The basis multiplied (with dot product) by the input
	@return The gradients to update w
	 */
	array<array<double, TYI>, CLASSES * NEURONS_IN> GradientW(char label, array<array<bool, T>, NEURONS_IN>& x, array<array<double, Ka>, TYI>& basis);

	/**
	Compute the gradient of the biases
	@param label The correct digit
	@return The gradients to update gamma
	*/
	array<double, CLASSES> GradientGamma(char label);

	/**
	Updates the biases using the errors
	@params errors The errors for updating the biases
	@see ComputeErrors
	*/
	void UpdateGammas(array<double, CLASSES>& gradients);
};
